<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>所见之事·所感之悟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <meta name="keywords" content="漠">
  
  <meta name="description" content="所见之事·所感之悟">
<meta name="keywords" content="漠">
<meta property="og:type" content="website">
<meta property="og:title" content="所见之事·所感之悟">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="所见之事·所感之悟">
<meta property="og:description" content="所见之事·所感之悟">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="所见之事·所感之悟">
<meta name="twitter:description" content="所见之事·所感之悟">
  
    <link rel="alternate" href="/atom.xml" title="所见之事·所感之悟" type="application/atom+xml">
  
  
    <link rel="icon" href="/images/photo.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlight.css">
</head>
</html>
<body>
  <div id="fullpage" class="mobile-nav-right">
    
      <div id="wrapper" style="width:100%;height:100%;background: url(/images/bgs.png);background-size: cover" title="图片来自网络">
    
    
      <header id="header">
  <div id="nav-toggle" class="nav-toggle"></div>
  <div class="head-box global-width">
    <nav class="nav-box nav-right">
      
        <a class="nav-item" href="/" title="">首页</a>
      
        <a class="nav-item" href="/archives" title="">归档</a>
      
        <a class="nav-item" href="/category" title="">分类</a>
      
    </nav>
  </div>
</header>
      <div id="middlecontent" title class="global-width sidebar-right">
        <section id="main">
  
    <article id="post-浏览器缓存机制" class="article global-container article-type-post" itemscope="" itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/浏览器缓存机制/">浏览器缓存机制-Nginx控制浏览器缓存</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/04/15/浏览器缓存机制/" class="article-date">
  <time datetime="2019-04-15T07:18:54.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/浏览器/">浏览器</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/浏览器缓存/">浏览器缓存</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-doorframe" itemprop="articleBody">
      
        <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文的主要目的是解决浏览器缓存的问题，主要讲述浏览器缓存逻辑以及如何控制浏览器缓存</p>
<h1 id="二、引言"><a href="#二、引言" class="headerlink" title="二、引言"></a>二、引言</h1><p>关于这个问题，在网上进行搜索之后会有很多解决方案，但是却不一定有效或者适合，最多见到的方法有两种：</p>
<ul>
<li>1 添加时间戳</li>
<li>2 配置cache-control</li>
</ul>
<h2 id="1、时间戳"><a href="#1、时间戳" class="headerlink" title="1、时间戳"></a>1、时间戳</h2><p>对于第一种的方法，直白的讲就是给js文件添加一个 ‘版本号’，已求达到欺骗浏览器的目的，使得浏览器认为js文件版本已更新</p>
<p>那你修改过test.js在html页面中的引用就要改成像下面这个样子</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://resources.test.com/js/test.js?version=56965&quot;&gt;&lt;/script&gt;
</code></pre><p>每次修改test.js之后修改version后面的时间戳，这样浏览器就会忽略缓存从服务器请求新的文件，</p>
<p>但是，真正这么做了之后，还是会发现，即使所有修改过的文件在应用的时候都添加了时间戳了，但是页面缓存还是没有清除，</p>
<p>这又是为什么呢？原因很简单，你只对你修改过的文件添加了时间戳，但是html页面本身在这个时候已经被修改了，</p>
<p>html页面是所有静态资源的载体，如果不对它加上时间戳，所有的其他应用都会沿用旧的缓存，</p>
<p>所以，这个时候要让缓存失效，只需要在你的访问的网址上面再添加一个时间戳，例如：</p>
<pre><code>http://www.test.com/index.html?version=123456
</code></pre><p>但很明显，这种做法其实很不优雅，例如网站的访问地址是不能经常变更的，所以这种方法其实使用收到很大程度的限制，</p>
<h2 id="2、cache-control"><a href="#2、cache-control" class="headerlink" title="2、cache-control"></a>2、cache-control</h2><p>网上很多教程都会写在meta标签上添加cache-control，大概像下面这个样子</p>
<pre><code>&lt;meta name=&quot;Cache-Control&quot; content=&quot;no-cache&quot;&gt;
</code></pre><p>但是，这样做，一点卵用都没有，这样完全没办法避免浏览器的缓存</p>
<p>添加cache-control没错，但是需要在响应头添加，</p>
<p>我们都知道，客户端跟服务端的交互用的都是http协</p>
<p>由服务端回传给客户端的数据我们称之为响应数据，分为响应头（Response Headers）和响应体（Response Body），</p>
<p>响应头一般用于指导浏览器以什么样的方式呈现数据，</p>
<pre><code>例如:编码，解码，压缩，请求能否跨域等操作，Cache-Control是其中的一个，用来指导浏览器如何管理缓存，
</code></pre><h1 id="三、缓存过程分析"><a href="#三、缓存过程分析" class="headerlink" title="三、缓存过程分析"></a>三、缓存过程分析</h1><p>在解释浏览器缓存机制之前，先来分析一下浏览器的 ‘缓存过程’</p>
<p><img src="浏览器缓存机制\2.png" alt="2"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存。</p>
<h2 id="1、强缓存"><a href="#1、强缓存" class="headerlink" title="1、强缓存"></a>1、强缓存</h2><p><strong>强缓存</strong>：<strong>不会向服务器发送请求，直接从缓存中读取资源，</strong></p>
<p>​    在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。</p>
<p>强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control</p>
<h3 id="a）Expires"><a href="#a）Expires" class="headerlink" title="a）Expires"></a>a）Expires</h3><p><strong>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点</strong>。</p>
<p>​    也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p>
<p><strong>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效</strong>。</p>
<p>​    </p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></table></figure></div>
<p>表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后<strong>过期</strong>，需要再次请求。</p>
<h3 id="b）Cache-Control"><a href="#b）Cache-Control" class="headerlink" title="b）Cache-Control"></a>b）Cache-Control</h3><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Cache-Control:max-age=300`</span><br></pre></td></tr></table></figure></div>
<p>则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p>
<p><img src="浏览器缓存机制\3.png" alt="3"></p>
<p><strong>public</strong>：<strong>所有内容都将被缓存（客户端和代理服务器都可缓存）</strong>。</p>
<p>​    具体来说响应可被任何中间节点缓存，如 Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，中间的proxy可以缓存资源，比如下次再请求同一资源proxy1直接把自己缓存的东西给 Browser 而不再向proxy2要。</p>
<p><strong>private</strong>：<strong>所有内容只有客户端可以缓存</strong>，</p>
<p>​    Cache-Control的默认取值。具体来说，表示中间节点不允许缓存，对于Browser &lt;– proxy1 &lt;–  proxy2 &lt;– Server，proxy 会老老实实把Server 返回的数据发送给proxy1,自己不缓存任何数据。当下次Browser再次请求时proxy会做好请求转发而不是自作主张给自己缓存的数据。</p>
<p><strong>no-cache</strong>：<strong>客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定</strong>。</p>
<p>​    表示不使用 Cache-Control的缓存控制方式做前置验证，而是使用 Etag 或者Last-Modified字段来控制缓存。</p>
<p><strong>注意：</strong>no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p>
<p><strong>no-store</strong>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p>
<p><strong>max-age</strong>：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p>
<p><strong>s-maxage</strong>（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。</p>
<p>​    比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。<strong>s-maxage的优先级高于max-age</strong>。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
<p><strong>max-stale</strong>：能容忍的最大过期时间。</p>
<p>​    max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应（age表示响应由源站生成或确认的时间与当前时间的差值）。</p>
<p><strong>min-fresh</strong>：</p>
<p>​    能够容忍的最小新鲜度。min-fresh标示了客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p>
<p><img src="浏览器缓存机制\4.png" alt="4"></p>
<p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。</p>
<p>比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等</p>
<h3 id="c）Expires和Cache-Control"><a href="#c）Expires和Cache-Control" class="headerlink" title="c）Expires和Cache-Control"></a>c）Expires和Cache-Control</h3><p>其实这两者差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，</p>
<p><strong>两者同时存在的话，Cache-Control优先级高于Expires</strong>；</p>
<p>在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p>
<p>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容，</p>
<p><strong>那我们如何获知服务器端内容是否已经发生了更新呢</strong>？此时我们需要用到协商缓存策略</p>
<h2 id="2、协商缓存"><a href="#2、协商缓存" class="headerlink" title="2、协商缓存"></a>2、协商缓存</h2><p><strong>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况</strong>：</p>
<ul>
<li>协商缓存生效，返回304和Not Modified</li>
</ul>
<p><img src="浏览器缓存机制\5.png" alt="5"></p>
<ul>
<li>协商缓存失效，返回200和请求结果</li>
</ul>
<p><img src="浏览器缓存机制\6.png" alt="6"></p>
<p>协商缓存可以通过设置两种 HTTP Header 实现：<strong>Last-Modified 和 ETag 。</strong></p>
<h3 id="a）Last-Modified和If-Modified-Since"><a href="#a）Last-Modified和If-Modified-Since" class="headerlink" title="a）Last-Modified和If-Modified-Since"></a>a）Last-Modified和If-Modified-Since</h3><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</span><br></pre></td></tr></table></figure></div>
<p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；</p>
<p>服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，</p>
<p>如果没有变化，返回304和空的响应体，直接从缓存读取，</p>
<p>如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</p>
<p>但是 Last-Modified 存在一些弊端：</p>
<ul>
<li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li>
<li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li>
</ul>
<p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 <code>ETag</code> 和<code>If-None-Match</code></p>
<h3 id="b）ETag和If-None-Match"><a href="#b）ETag和If-None-Match" class="headerlink" title="b）ETag和If-None-Match"></a>b）ETag和If-None-Match</h3><p><strong>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成</strong></p>
<p>浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，</p>
<p>服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。</p>
<p>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；</p>
<p>如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p>
<p><img src="浏览器缓存机制\7.png" alt="7"></p>
<h2 id="3、两者之间对比"><a href="#3、两者之间对比" class="headerlink" title="3、两者之间对比"></a>3、两者之间对比</h2><p>### </p>
<ul>
<li>首先在精确度上，Etag要优于Last-Modified。</li>
</ul>
<p>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p>
<ul>
<li>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</li>
<li>第三在优先级上，服务器校验优先考虑Etag</li>
</ul>
<p>解释完这些之后，看一下浏览器中的这些参数吧</p>
<p><img src="浏览器缓存机制\10.png" alt="10"></p>
<h1 id="四、浏览器缓存机制"><a href="#四、浏览器缓存机制" class="headerlink" title="四、浏览器缓存机制"></a>四、浏览器缓存机制</h1><p>以上介绍了浏览器的两种缓存策略，对于浏览器缓存的一些流程及逻辑和相关配置简单有了些了解。那么接下来就是浏览器的缓存机制详解</p>
<h2 id="1、两种缓存策略的规则："><a href="#1、两种缓存策略的规则：" class="headerlink" title="1、两种缓存策略的规则："></a>1、两种缓存策略的规则：</h2><p><strong>强制缓存</strong></p>
<ul>
<li><p>优先于协商缓存进行，</p>
</li>
<li><p>若强制缓存(Expires和Cache-Control)生效则直接使用缓存，</p>
</li>
<li><p>若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，</p>
</li>
</ul>
<p><strong>协商缓存</strong></p>
<ul>
<li>由服务器决定是否使用缓存，</li>
<li>若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；</li>
<li>生效则返回304，继续使用缓存</li>
</ul>
<h2 id="2、浏览器缓存机制"><a href="#2、浏览器缓存机制" class="headerlink" title="2、浏览器缓存机制"></a>2、浏览器缓存机制</h2><p>下面我们详细说一下如何浏览器的缓存机制，然后再说说如何通过响应头来控制浏览器的缓存，我们首先来看一张流程图</p>
<p><img src="浏览器缓存机制\8.png" alt="1"></p>
<p>这张图片是浏览器访问一个有缓存的页面的时候的决策流程，大体上的流程是这样子的，</p>
<ul>
<li>当你访问一个页面的时候，浏览器会检查本地是否有缓存</li>
<li><p>若果没有缓存，那么就向服务器发出请求并缓存</p>
</li>
<li><p>如果有缓存，浏览器会先检查本地缓存是否过期，</p>
</li>
<li><p>如果未过期，则直接访问本地缓存，不再从服务器端获取，此时的状态码为200（from cache）</p>
</li>
<li><p>如已经过期，则会发送一个http请求到服务端，检查两个标识中的其中一个，Etag或者Last-Modified，向浏览器询问资源是否过期，</p>
</li>
<li><p>如未过期，则浏览器会返回一个304状态码，这是浏览器就不会重新下载文件，依旧沿用缓存的内容，</p>
</li>
<li><p>但如果此时服务器检测到资源已经过期了，那么就会返回200状态码，并在响应体中返回最新的资源，覆盖缓存，这样浏览器就能拿到最新的资源了。</p>
</li>
</ul>
<h2 id="3、缺失的配置"><a href="#3、缺失的配置" class="headerlink" title="3、缺失的配置"></a>3、缺失的配置</h2><p>看到这里，不知道你是否存在这样一个疑问:<strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p>
<p>​    对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。</p>
<h1 id="五、补充-缓存位置"><a href="#五、补充-缓存位置" class="headerlink" title="五、补充-缓存位置"></a>五、补充-缓存位置</h1><p>看过以上的介绍和解释，个人对于缓存位置还是比较感兴趣的，所以又把略过的东西补充了回来</p>
<p><strong>从缓存位置上来说分为四种</strong>，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3 id="1、Service-Worker"><a href="#1、Service-Worker" class="headerlink" title="1、Service Worker"></a>1、Service Worker</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</p>
<p>使用 Service Worker的话，传输协议必须为 HTTPS。</p>
<p>因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p><strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：</p>
<ul>
<li>首先需要先注册 Service Worker，</li>
<li>然后监听到 install 事件以后就可以缓存需要的文件，</li>
<li>那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</li>
</ul>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。</p>
<p>也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。</p>
<p>但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p>
<h3 id="2、Memory-Cache"><a href="#2、Memory-Cache" class="headerlink" title="2、Memory Cache"></a>2、Memory Cache</h3><p><strong>Memory Cache 也就是内存中的缓存</strong></p>
<p>主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。</p>
<p>读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，</p>
<p>可是缓存持续性很短，会随着进程的释放而释放。 </p>
<p><strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了</strong>。</p>
<p><strong>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</strong><br>    这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。</p>
<p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p>
<p><img src="浏览器缓存机制\9.png" alt="img"></p>
<p>内存缓存中有一块重要的缓存资源是preloader相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。</p>
<p>preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。</p>
<p>需要注意的事情是，<strong>内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验</strong>。</p>
<h3 id="3、Disk-Cache"><a href="#3、Disk-Cache" class="headerlink" title="3、Disk Cache"></a>3、Disk Cache</h3><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，</p>
<p><strong>比之 Memory Cache 胜在容量和存储时效性上</strong>。</p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。</p>
<p>它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。</p>
<p>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据，绝大部分的缓存都来自 Disk Cache</p>
<p><strong>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</strong><br> 关于这点，网上说法不一，不过以下观点比较靠得住：</p>
<ul>
<li>对于大文件来说，大概率是不存储在内存中的，反之优先</li>
<li>当前系统内存使用率高的话，文件优先存储进硬盘</li>
</ul>
<h3 id="4、Push-Cache"><a href="#4、Push-Cache" class="headerlink" title="4、Push Cache"></a>4、Push Cache</h3><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。</p>
<p><strong>它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂</strong>，</p>
<p>在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p>
<p>Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读<code>Jake Archibald</code>的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F" target="_blank" rel="noopener">HTTP/2 push is tougher than I thought</a> 这篇文章，文章中的几个结论：</p>
<ul>
<li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p>
<p>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略</p>
<h1 id="六、配置缓存策略"><a href="#六、配置缓存策略" class="headerlink" title="六、配置缓存策略"></a>六、配置缓存策略</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><strong>nginx</strong>可以通过 expires 指令来设置浏览器的Header<br>语法： expires [time|epoch|max|off]<br>默认值： expires off<br>作用域： http, server, location<br>使用本指令可以控制HTTP应答中的“Expires”和“Cache-Control”的头标，（起到控制页面缓存的作用）。<br>可以在time值中使用正数或负数。“Expires”头标的值将通过当前系统时间加上您设定的 time 值来获得。<br>epoch 指定“Expires”的值为 1 January, 1970, 00:00:01 GMT。<br>max 指定“Expires”的值为 31 December 2037 23:59:59 GMT，“Cache-Control”的值为10年。<br>-1 指定“Expires”的值为 服务器当前时间 -1s,即永远过期</p>
<h2 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h2><p>例子：<br>图片缓存30天</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`location ~.*\.(jpg|png|jpeg)$`` ``&#123;`` ``expires 30d;`` ``&#125;`</span><br></pre></td></tr></table></figure></div>
<p>js css缓存一小时</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`location ~.*\.(js|css)?$`` ``&#123;`` ``expires 1h;`` ``&#125;`</span><br></pre></td></tr></table></figure></div>
<p>浏览器缓存的头信息，在nginx里也是可以设置的，如下。</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#配置在server节点下 `` ``#将favicon.ico放到nginx安装目录的html目录下 ``location = /favicon.ico &#123; ``  ``root html; ``  ``index index.html index.htm; ``  ``expires 30d; #会同时设置Expires 和 Cache-Control:max-age ``  ``add_header Pragma Pragma; `` ``&#125; `</span><br></pre></td></tr></table></figure></div>
<p>或者</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~.*\.(js|css|html|png|jpg)$ &#123;</span><br><span class="line">        add_header Cache-Control &quot;private, no-cache, no-store, must-revalidate&quot;;</span><br><span class="line">        add_header Expires &quot;Sat, 01 Jan 2000 00:00:00 GMT&quot;;</span><br><span class="line">        add_header Pragma no-cache;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>设置完以后，请求通过浏览器查看。 缓存的参数（上面有截取了浏览器缓存的相关参数的图片）</p>
<p>缓存生效。</p>
<h2 id="3、-注意事项"><a href="#3、-注意事项" class="headerlink" title="3、 注意事项"></a>3、 注意事项</h2><p>1、调试的时候要注意几个问题：<br>四类用户行为影响缓存:F5刷新，F5强制刷新，点击刷新，地址栏回车。会让Expires失效</p>
<p>2、Nginx中的配置会覆盖HTML的http-equiv=”Cache-control”配置。</p>
<p>　　　但是如果HTML中的加了下面3个标签，浏览器端效果还是只能no-cache。（从效果上来看：Nginx的Cache-control配置无效）</p>
<p>​          因为Nginx的Cache-control配置只是覆盖了Cache-control（如果html加的是后面两个标签，Nginx还是有效的），而Pragma仍然起着作用。</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt; </span><br><span class="line">　　&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache;max-age=0&quot;/&gt; </span><br><span class="line">　　&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;/&gt;</span><br></pre></td></tr></table></figure></div>
<h1 id="七、补充-nignx-location配置"><a href="#七、补充-nignx-location配置" class="headerlink" title="七、补充-nignx location配置"></a>七、补充-nignx location配置</h1><h2 id="1、语法规则："><a href="#1、语法规则：" class="headerlink" title="1、语法规则："></a>1、语法规则：</h2><p><strong>location 正则 { 规则配置 }</strong></p>
<p><strong>location [=|~|~*|^~] /uri/ { … }</strong></p>
<ul>
<li><p>= 开头表示精确匹配</p>
</li>
<li><p>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。</p>
<p>nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。</p>
</li>
<li><p>~ 开头表示区分大小写的正则匹配</p>
</li>
<li><p>~*  开头表示不区分大小写的正则匹配</p>
</li>
<li><p>!~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则</p>
</li>
<li><p>/ 通用匹配，任何请求都会匹配到。</p>
</li>
</ul>
<p>多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：</p>
<p>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。</p>
<p>当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</p>
<h2 id="2、例子，有如下匹配规则："><a href="#2、例子，有如下匹配规则：" class="headerlink" title="2、例子，有如下匹配规则："></a>2、例子，有如下匹配规则：</h2><p>A.精确匹配，必须是127.0.0.1/</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">	规则A</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></div>
<p>B.精确匹配，必须是127.0.0.1/login</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = /login &#123;</span><br><span class="line">	规则B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>C.非精确匹配，并且不区分大小写，比如127.0.0.1/static/jq.js</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ^~ /static/ &#123;</span><br><span class="line"></span><br><span class="line">	规则C</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>D.区分大小写，以gif,jpg,js结尾</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line"></span><br><span class="line">	规则D</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>E.不区分大小写，匹配.png结尾的</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~\* \.png$ &#123;</span><br><span class="line"></span><br><span class="line">	规则E</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>F.区分大小写，匹配不已.xhtml结尾的</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location !~ \.xhtml$ &#123;</span><br><span class="line"></span><br><span class="line">	规则F</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>G.   .XHTML</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location !~\* \.xhtml$ &#123;</span><br><span class="line"></span><br><span class="line">	规则G</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>H.什么都可以</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"></span><br><span class="line">	规则H</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>那么产生的效果如下：</p>
<p>访问根目录/， 比如<code>http://localhost/</code> 将匹配规则A</p>
<p>访问<code>http://localhost/login</code> 将匹配规则B，</p>
<p><code>http://localhost/register</code> 则匹配规则H</p>
<p>访问<code>http://localhost/static/a.html</code>将匹配规则C</p>
<p>访问<code>http://localhost/a.gif, http://localhost/b.jpg</code>将匹配规则D和规则E，但是规则D顺序优先，规则E不起作用， 而<code>http://localhost/static/c.png</code>则优先匹配到 规则C</p>
<p>访问 <code>http://localhost/a.PNG</code> 则匹配规则E， 而不会匹配规则D，因为规则E不区分大小写。</p>
<p>访问<code>http://localhost/a.xhtml</code>不会匹配规则F和规则G，</p>
<p><code>http://localhost/a.XHTML</code>不会匹配规则G，因为不区分大小写。规则F，规则G属于排除法，符合匹配规则但是不会匹配到，所以想想看实际应用中哪里会用到。</p>
<p>访问<code>http://localhost/category/id/1111</code> 则最终匹配到规则H，因为以上规则都不匹配，这个时候应该是nginx转发请求给后端应用服务器，比如FastCGI（php），tomcat（jsp），nginx作为方向代理服务器存在。</p>
<p>所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</p>
<p>直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。<br>这里是直接转发给后端应用服务器了，也可以是一个静态首页</p>
<p>第一个必选规则</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line"></span><br><span class="line">	proxy_pass http:``//tomcat``:8080``/index`</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</p>
<p>有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ^~ ``/static/` `&#123;</span><br><span class="line"></span><br><span class="line">root ``/webroot/static/``;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line"></span><br><span class="line">root ``/webroot/res/``;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第三个规则就是通用规则，用来转发动态请求到后端应用服务器<br>非静态文件请求就默认是动态请求，自己根据实际把握<br>毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</p>
<div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"></span><br><span class="line">	proxy_pass http:``//tomcat``:8080/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3、未试验过的其他信息："><a href="#3、未试验过的其他信息：" class="headerlink" title="3、未试验过的其他信息："></a>3、未试验过的其他信息：</h2><h3 id="1、ReWrite语法"><a href="#1、ReWrite语法" class="headerlink" title="1、ReWrite语法"></a>1、ReWrite语法</h3><p>last – 基本上都用这个Flag。<br>break – 中止Rewirte，不在继续匹配<br>redirect – 返回临时重定向的HTTP状态302<br>permanent – 返回永久重定向的HTTP状态301<br>1、下面是可以用来判断的表达式：<br>-f和!-f用来判断是否存在文件<br>-d和!-d用来判断是否存在目录<br>-e和!-e用来判断是否存在文件或目录<br>-x和!-x用来判断文件是否可执行<br>2、下面是可以用作判断的全局变量<br>例：<a href="http://localhost:88/test1/test2/test.php" target="_blank" rel="noopener">http://localhost:88/test1/test2/test.php</a><br>$host：localhost<br>$server_port：88<br>$request_uri：<a href="http://localhost:88/test1/test2/test.php" target="_blank" rel="noopener">http://localhost:88/test1/test2/test.php</a><br>$document_uri：/test1/test2/test.php<br>$document_root：D:\nginx/html<br>$request_filename：D:\nginx/html/test1/test2/test.php </p>
<h3 id="2、Redirect语法"><a href="#2、Redirect语法" class="headerlink" title="2、Redirect语法"></a>2、Redirect语法</h3><p>server {<br>listen 80;<br>server_name start.igrow.cn;<br>index index.html index.php;<br>root html;<br>if ($http_host !~ “^star.igrow.cn$&amp;quot {<br>rewrite ^(.*) <a href="http://star.igrow.cn$1" target="_blank" rel="noopener">http://star.igrow.cn$1</a> redirect;<br>}<br>} </p>
<h3 id="3、防盗链"><a href="#3、防盗链" class="headerlink" title="3、防盗链"></a>3、防盗链</h3><div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|swf)$ &#123; </span><br><span class="line"></span><br><span class="line">valid_referers none blocked start.igrow.cn sta.igrow.cn; </span><br><span class="line">if ($invalid_referer) &#123; </span><br><span class="line">rewrite ^/ http://$host/logo.png; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="4、根据文件类型设置过期时间"><a href="#4、根据文件类型设置过期时间" class="headerlink" title="4、根据文件类型设置过期时间"></a>4、根据文件类型设置过期时间</h3><div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(js|css|jpg|jpeg|gif|png|swf)$ &#123; </span><br><span class="line">if (-f $request_filename) &#123; </span><br><span class="line">expires 1h; </span><br><span class="line">break; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="5、禁止访问某个目录"><a href="#5、禁止访问某个目录" class="headerlink" title="5、禁止访问某个目录"></a>5、禁止访问某个目录</h3><div class="highlight-box" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(txt|doc)$&#123; </span><br><span class="line">root /data/www/wwwroot/linuxtone/test; </span><br><span class="line">deny all; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>++ 一些可用的全局变量<br>$args<br>$content_length<br>$content_type<br>$document_root<br>$document_uri<br>$host<br>$http_user_agent<br>$http_cookie<br>$limit_rate<br>$request_body_file<br>$request_method<br>$remote_addr<br>$remote_port<br>$remote_user<br>$request_filename<br>$request_uri<br>$query_string<br>$scheme<br>$server_protocol<br>$server_addr<br>$server_name<br>$server_port<br>$uri</p>

      
    </div>
    
  </div>
  
  
</article>

  
    <article id="post-技术及面试总结" class="article global-container article-type-post" itemscope="" itemprop="blogPost">
  
    <header class="article-header">
      
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/技术及面试总结/">技术及面试总结</a>
    </h1>
  

    </header>
  
  <div class="article-meta">
    <a href="/2019/04/15/技术及面试总结/" class="article-date">
  <time datetime="2019-04-15T06:19:33.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

    
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

  </div>
  

  <div class="article-inner">
    
    <div class="article-content article-content-doorframe" itemprop="articleBody">
      
        
      
    </div>
    
  </div>
  
  
</article>

  



</section>
        <aside id="sidebar">
  
    <div class="widget-box">
  <div class="avatar-box">
    <img class="avatar" src="/images/photo.jpg" title="图片来自网络">
    <h3 class="avatar-name">
      
        浮梦之殇
      
    </h3>
    <p class="avatar-slogan">
      所见之事·所感之悟
    </p>
  </div>
</div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/浏览器/">浏览器</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nginx/">Nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器缓存/">浏览器缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-box">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Nginx/" style="font-size: 10px;">Nginx</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/技术/" style="font-size: 10px;">技术</a> <a href="/tags/浏览器缓存/" style="font-size: 10px;">浏览器缓存</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li></ul>
    </div>
  </div>

  
    
  <div class="widget-box">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/15/浏览器缓存机制/">浏览器缓存机制-Nginx控制浏览器缓存</a>
          </li>
        
          <li>
            <a href="/2019/04/15/技术及面试总结/">技术及面试总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer" style="position:absolute;bottom:0px;width:100%;">
  <div class="foot-box global-width">
    &copy; 2019 漠 &nbsp;&nbsp;
    驱动于 <a href="http://hexo.io/" target="_blank">Hexo</a><br>
    <script async src="/js/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">阁下是第<span id="busuanzi_value_site_pv"></span>个访客</span>
  </div>
</footer>
      

<script src="/js/jquery-2.0.3.min.js"></script>

  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



    </div>
    <nav id="mobile-nav" class="mobile-nav-box">
  <div class="mobile-nav-img mobile-nav-top"></div>
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/category" class="mobile-nav-link">分类</a>
  
  <div class="mobile-nav-img  mobile-nav-bottom"></div>
</nav>    
  </div>
</body>
</html>